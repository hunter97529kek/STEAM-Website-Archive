<HTML>
<HEAD>
<TITLE>Zoner's Halflife Tools : Command Reference</TITLE>
<link rel="stylesheet" type="text/css" href="zhlt.css">
</HEAD>
<BODY>
<H1>Zoner's Halflife Tools : Command Reference</H1>

<TABLE>
<TR><TD class="headingCELL"><BR>Shared Options</TD></TR>
<TR><TD>
        <TABLE width="100%">
        <TR><TD class="topicalCELL" width="120"><B>-texdata #</B></TD><TD class="textualCELL">Alter maximum texture memory limit (in kb).<P>Halflife was built with a 2Mb texture limit, as was Opposing Force.  The ZHLT default limit is 4Mb.  Even 4Mb can be a bit much, when combined with model textures, skies, hud graphics, and more.  This is especially true of people with older cards (Voodoo 1 and 2's, etc).</TD></TR>
        <TR><TD class="topicalCELL" width="120"><B>-chart</B></TD><TD class="textualCELL">display bsp statitics<P>This option will cause the program to print out the bsp statistics right before it writes out the bsp.  It is most handy to do -chart with hlrad and hlvis at the end of the compiles.  The ripent program will alway displays the chart.</TD></TR>
        <TR><TD class="topicalCELL" width="120"><B>-low | -high</B></TD><TD class="textualCELL">run program an altered priority level<P>Setting the priority of the compile tools to -low is very handy, as you can multitask and do other things without really feeling the drain of the compile programs on the system, provided there is enough memory for the tools and the other programs you use.</TD></TR>
        <TR><TD class="topicalCELL" width="120"><B>-nolog</B></TD><TD class="textualCELL">don't generate the compile logfiles<P>This option just disables the generation of the .log and .err files which are normally generated whenever the compile tools run.</TD></TR>
        <TR><TD class="topicalCELL" width="120"><B>-threads #</B></TD><TD class="textualCELL">manually specify the number of threads to run<P>This option is generally only necessary on the non-windows versions of the tools, where there is not a standard way to detect the number of processors in the system and auto-set the value.  It can be manually set on windows machines, primarily if you wish to use fewer threads than processors.</TD></TR>
        <TR><TD class="topicalCELL" width="120"><B>-estimate</B></TD><TD class="textualCELL">display estimated time during compile<P>This option replaces the 10...20... style progress indicators with a estimate bar with some estimated completion times, as well as the exact number of the current job and how many jobs there are to do.  The three different times remaining factor in varying amounts of historical data to guess how much longer it will take to run.  It is good for a ballpark figure, but frequently not much more accurate than that.</TD></TR>
        <TR><TD class="topicalCELL" width="120"><B>-verbose</B></TD><TD class="textualCELL">compile with verbose messages<P>Many of the tools have 'minor warnings' and informative messages which are displayed when verbose mode is set.  As the ZHLT 2.x series develops, many of the developer specific settings are being moved to developer messages, while the mapper related messages will remain as verbose messages.</TD></TR>
        <TR><TD class="topicalCELL" width="120"><B>-noinfo</B></TD><TD class="textualCELL">Do not show tool configuration information<P>ZHLT 2.1 added a configuration display for each of the tools as they run, to display the current settings for all configurable options as well as their defaults.  This sometimes causes problems with other programs, most notably when compiling within Worldcraft, it likes to crash when too much stuff scrolls into its compile process window.</TD></TR>
        <TR><TD class="topicalCELL" width="120"><B>-dev #</B></TD><TD class="textualCELL">compile with developer message<P>Internal ZHLT debugging messages have been slowly added to the tools.  This variable sets the 'level' to display.  In order (starting with 0 and going up) : Off, Error, Warning, Info, Fluff, Spam, MegaSpam.  Generally this option should never be used except at request, to diagnose a compile problem on an end-users machine.</TD></TR>
        </TABLE>
<TR><TD>
<TR><TD class="headingCELL"><BR>HLCSG</TD></TR>
<TR><TD>
        <TABLE width="100%">
        <TR><TD class="topicalCELL" width="120"><B>-nowadtextures</B></TD><TD class="textualCELL">include all used textures into bsp<P>This option is obsoleted by -wadinclude and is only left in to retain some backwards compatibility.</TD></TR>
        <TR><TD class="topicalCELL" width="120"><B>-wadinclude file</B></TD><TD class="textualCELL">place textures used from wad specified into bsp<P>This option will cause csg to include used textures from the named wadfile into the bsp.  It does partial name matching, is not case sensitive, and can also match directory names.  If multiple includes need to be done, -wadinclude must be specified multiple times, once for each include.  Only textures actually used in the map are included into the bsp</TD></TR>
        <TR><TD class="topicalCELL" width="120"><B>-noclip</B></TD><TD class="textualCELL">don't create clipping hull<P>Halflife like Quake1, has 4 hulls, 1 visual hull and 3 collision hulls.  This option disables generation of the collision hulls for a small savings in compile time.  Note that the world will not be solid at all (everything will fall into the void) with this option set.</TD></TR>
        <TR><TD class="topicalCELL" width="120"><B>-onlyents</B></TD><TD class="textualCELL">do an entity update from .map to .bsp<P>This option will take the entities from the .map file and update them into the bsp file.  For the most part, entities can only be edited.  Adding or removing any can reorder the other entities which frequently breaks brush based entities, especially triggers.</TD></TR>
        <TR><TD class="topicalCELL" width="120"><B>-noskyclip</B></TD><TD class="textualCELL">disable automatic clipping of SKY brushes<P>By default hlcsg will CLIP all SKY brushes, as well as remove all non-sky faces on the 'inside' of a sky brush (which eases up vis time, and improves some time and memory usage in rad as well)</TD></TR>
        <TR><TD class="topicalCELL" width="120"><B>-tiny #</B></TD><TD class="textualCELL">minmum brush face surface area before it is discarded<P>Tiny brush faces are outright removed.  The current cut-off is 0.5 square units.  It is dangerous to drop faces in this manner, as the BSP tree for the world can be unusable, or generate leaf portal errors or hall-of-mirrors vis errors.</TD></TR>
        <TR><TD class="topicalCELL" width="120"><B>-brushunion #</B></TD><TD class="textualCELL">threshold to warn about overlapping brushes<P>This option is a mapper debugging feature.  The value passed in is a percentage (0 to 100) of overlap of two brushes before a warning is printed.  Starting with a high value (95+) is a good idea, as going too low to start can print hundreds or thousands of messages.  The brush numbers of the intersecting brushes and the percentage in which they intersect each other is displayed for each occurence.  This option is off by default as it dramatically slows down hlcsg to do these calculations. </TD></TR>
        <TR><TD class="topicalCELL" width="120"><B>-hullfile</B></TD><TD class="textualCELL">Load a custom hullfile<P>Loads a custom set of hulls for the collision hull generation.  The file is composed of 3 lines of 3 whitespace delimited numbers.  Each line is an X Y Z size of the bounding box it is for.  Only specific mod authors and their mapping teams should ever worry about this feature.</TD></TR>
        </TABLE>
<TR><TD>
<TR><TD class="headingCELL"><BR>HLBSP</TD></TR>
<TR><TD>
        <TABLE width="100%">
        <TR><TD class="topicalCELL" width="120"><B>-leakonly</B></TD><TD class="textualCELL">Run BSP only enough to check for LEAKs<P>If you already know a map has a leak, this is a good option to just save some time in hlbsp and just generate the pts file.</TD></TR>
        <TR><TD class="topicalCELL" width="120"><B>-subdivide #</B></TD><TD class="textualCELL">Sets the face subdivide size<P>Faces in Halflife are subdivided by this value (in units).  The default and maximum are both 240, and it should never need to be set lower (as it just increases r_speeds)</TD></TR>
        <TR><TD class="topicalCELL" width="120"><B>-maxnodesize #</B></TD><TD class="textualCELL">Sets the maximum portal node size<P>This option tweaks the maximum size of a portal node.  Setting it smaller will bsp the world into smaller chunks at the cost of higher r_speeds, but it can pay itself back in many cases with making vis either faster, or more accurate, or both.</TD></TR>
        <TR><TD class="topicalCELL" width="120"><B>-notjunc</B></TD><TD class="textualCELL">Don't break edges on t-junctions     (not for final runs)<P>This is a development/debugging option that should not be set in normal use</TD></TR>
        <TR><TD class="topicalCELL" width="120"><B>-noclip</B></TD><TD class="textualCELL">Don't process the clipping hull      (not for final runs)<P>This is a continuation of the -noclip option in hlcsg.  In this case it tells hlbsp that hlcsg was compiled with -noclip and to not attempt to BSP the collision hulls as they are not present in the bsp</TD></TR>
        <TR><TD class="topicalCELL" width="120"><B>-nofill</B></TD><TD class="textualCELL">Don't fill outside (will mask LEAKs) (not for final runs)<P>This step causes filling to not be performed, which will cause all the faces on the outside of the map to not be discarded.  It is probably a bad idea to rad a map that has been compiled this way, though vis should run normally.</TD></TR>
        </TABLE>
<TR><TD>
<TR><TD class="headingCELL"><BR>HLVIS</TD></TR>
<TR><TD>
        <TABLE width="100%">
        <TR><TD class="topicalCELL" width="120"><B>-fast</B></TD><TD class="textualCELL">Fast vis (NOT FOR FINAL COMPILES)<P>A fast vis is handy for running around in a developed map without dropping polygons.  However r_speeds will usually be pretty bad, as well as epoly counts.  The map can still be lit with hlrad, however its quality and compile time will both suffer as a result.  Maps should regularly be compiled without fast vis, as fast vis can mask a sudden increase in normal vis compile time.</TD></TR>
        <TR><TD class="topicalCELL" width="120"><B>-full</B></TD><TD class="textualCELL">Full vis.<P>This option enables extra calculations during vis, which help reduce the number of vis errors in a map over a normal vis.  The speed hit is approximately 30% over a normal vis.  r_speeds will generally be the same, though lower in some areas, and higher in others (primarily due to vis errors being fixed)</TD></TR>
    
    	</TABLE>
<TR><TD>
<TR><TD class="headingCELL"><BR>HLRAD</TD></TR>
<TR><TD>
        <TABLE width="100%">
        <TR><TD class="topicalCELL" width="120"><B>-sparse</B></TD><TD class="textualCELL">Enable low memory vismatrix algorithm<P>The original vismatrix algorithm was limited to 65535 patches due to its design.  Its memory usage also grew exponentially with the number of patches (patches * patches / 16 bytes).  This option enables a compressed vismatrix, which at the cost of extra CPU time, breaks the 65535 limit, and also uses about 10% of the memory the vismatrix would.</TD></TR>
        <TR><TD class="topicalCELL" width="120"><B>-nomatrix</B></TD><TD class="textualCELL">Disable usage of vismatrix entirely<P>As the sparse code does some compression, it requires a lot of thread synchronization and does not scale well past 2 CPU's.  The -nomatrix switch was added to address this.  However the addition of 'opaque brush entities' starting with ZHLT 2.2 hurts the -nomatrix method's performance quite a bit.  There is no vismatrix in this method at all, so it essentially reduces the memory requirements to zero for that structure.</TD></TR>

        <TR><TD class="topicalCELL" width="120"><B>-extra</B></TD><TD class="textualCELL">Turns on 9 point oversampling for lighting, making it look much better.</TD></TR>
        <TR><TD class="topicalCELL" width="120"><B>-bounce #</B></TD><TD class="textualCELL">Set number of radiosity bounces<P>This option sets the number of times light bounces in the radiosity pass.  By the time the code gets to this point, all the data is precomputed, and extra bounces are very fast.  It will make the shadows less harsh using more bounces, but can help light up dark areas much more naturally.</TD></TR>
        <TR><TD class="topicalCELL" width="120"><B>-ambient r g b</B></TD><TD class="textualCELL">Set ambient world light (0.0 to 1.0, r g b)<P>This option sets a minimum light value to every face so that nothing comes out pitch black. The values are red green blue, scaled from 0.0 to 1.0</TD></TR>
        <TR><TD class="topicalCELL" width="120"><B>-maxlight #</B></TD><TD class="textualCELL">Set maximum light intensity value<P>This option can be used to cap the bright spots, if you want a map to come out darker overall.</TD></TR>
        <TR><TD class="topicalCELL" width="120"><B>-circus</B></TD><TD class="textualCELL">Enable 'circus' mode for locating unlit lightmaps<P>This is a debugging option, which will cause all black pixels in any lightmap to be set to a random fullbright color.  It only looks at the direct lighting to make this determination, and ignores any bounced radiosity data for making this determination.</TD></TR>
        <TR><TD class="topicalCELL" width="120"><B>-nopaque</B></TD><TD class="textualCELL">Disable all entities using zhlt_lightflags 2 to block light.  Using opaque entities slows rad down, and using this option is useful for doing quicker non-final lighting compiles.</TD></TR>

        <TR><TD class="topicalCELL" width="120"><B>-smooth #</B></TD><TD class="textualCELL">Set smoothing threshold for blending (in degrees)<P>By default hlrad uses Phong shading on all faces.  If the angle between two edges is less than this value, it will be shaded with the Phong smoothing code, otherwise it won't.</TD></TR>
        <TR><TD class="topicalCELL" width="120"><B>-chop #</B></TD><TD class="textualCELL">Set radiosity patch size for normal textures<P>Each face in the world has a grid projected onto it, and chopped up into a rather coarse set of sample points.  These points are patches, and are what hlrad uses to do the bounced lighting calculations.  A higher chop sacrifices quality for both speed and memory consumption of hlrad.  A lower chop increases the quality at the expense of speed and memory usage.</TD></TR>
        <TR><TD class="topicalCELL" width="120"><B>-texchop #</B></TD><TD class="textualCELL">Set radiosity patch size for texture light faces<P>Texture light faces are chopped with a different granularity than the normal faces, primarily so that the lighting looks good.  Generally it should be half of the chop value.  Adding -extra to hlrad will automatically divide this value by 2 at runtime.</TD></TR>

        <TR><TD class="topicalCELL" width="120"><B>-notexscale #</B></TD><TD class="textualCELL">Do not scale radiosity patches with texture scale<P>By default, hlrad will take the texture scale and apply it to the chopping grid which is projected onto it.  This option turns that off, and almost always increases the number of patches in a map as most maps have many walls scaled up to 2 and 3.</TD></TR>
        <TR><TD class="topicalCELL" width="120"><B>-coring #</B></TD><TD class="textualCELL">Set lighting threshold before blackness<P>This value controls how much light it takes before a surface will be lit with a non-black value.</TD></TR>
        <TR><TD class="topicalCELL" width="120"><B>-dlight #</B></TD><TD class="textualCELL">Set direct lighting threshold<P>This option is similar to -maxlight, except that it re-normalizes the direct lighting values instead of clipping them if they are too high.</TD></TR>
        <TR><TD class="topicalCELL" width="120"><B>-dscale #</B></TD><TD class="textualCELL">Set direct lighting scale<P>Due to a bug in the original version of qrad, the direct lighting layer was added into the final lighting twice.  The correct thing to do is only have it in there once, but at the time too many maps had been created with this assumption and it was left in there.  This has been corrected as a command line switch, to scale the direct lighting by.<P>Using the value of '1' would generate the most correct looking maps.  However, since this is configurable it has a few other uses.  Using a value of '0' will remove the direct lighting completely from a map and it will only be lit with radiosity lighting.  This ends up 'opposite' of -bounce 0, and can be used to check the radiosity lighting for glitches.  Using larger values, like 3 or 4, cause extremely harsh direct lighting relation to the shadows and might be of use in desert or arctic maps.</TD></TR>
        <TR><TD class="topicalCELL" width="120"><B>-nolerp</B></TD><TD class="textualCELL">Disable three multi-point interpolation for radiosity patch blending, use nearest point sample instead.</TD></TR>

        <TR><TD class="topicalCELL" width="120"><B>-fade #</B></TD><TD class="textualCELL">Set global fade (larger values = shorter lights)<P>This value adds in an artificial factor into the normal (1 / dist * dist) inverse square falloff calculations, by multiplying the denominator of the scale by the fade value.  Point lights can set their own individual fade and falloff values, which override any global setting on the command line.  These calculations only affect the direct lighting layer, as the radiosity pass always uses plain inverse square falloff.</TD></TR>
        <TR><TD class="topicalCELL" width="120"><B>-falloff #</B></TD><TD class="textualCELL">Set global falloff mode (1 = inv linear, 2 = inv square)<P>This option can change the normal inverse square falloff of lighting in the direct lighting layer with inverse falloff.</TD></TR>
        <TR><TD class="topicalCELL" width="120"><B>-scale #</B></TD><TD class="textualCELL">Set global light scaling value<P>This option scales the final light values right after the direct lighting layer is added to the radiosity bounced lighting layer.  Low values make the world darker, higher values make it brighter.</TD></TR>
        <TR><TD class="topicalCELL" width="120"><B>-gamma #</B></TD><TD class="textualCELL">Set global gamma value<P>This option also occurs after the direct and radiosity layers are added together, and a global gamma correction is calculated and applied to the lighting before it is finalized</TD></TR>

        <TR><TD class="topicalCELL" width="120"><B>-sky #</B></TD><TD class="textualCELL">Set ambient sunlight contribution in the shade outside<P>Many faces have line of sight to sky, but fall in the shadow of some other object.  This option affects how much of the normal sky lighting is put into the shadows.</TD></TR>
        <TR><TD class="topicalCELL" width="120"><B>-lights file</B></TD><TD class="textualCELL">Manually specify a lights.rad file to use<P>A single .rad file can be added to the compile manually, in addition to the defaults of lights.rad and mapname.rad</TD></TR>
        <TR><TD class="topicalCELL" width="120"><B>-noskyfix</B></TD><TD class="textualCELL">Disable light_environment being global<P>ZHLT 2.1 added a simpler more manageable system for light_environments.  The new behavior is that a map only needs a single light_environment entity to light up all sky everywhere.  The placement of the entity no longer matters.  The -noskyfix option turns this feature off and enables the original code which require multiple light_environments to properly light up an outdoor area.</TD></TR>
        <TR><TD class="topicalCELL" width="120"><B>-incremental</B></TD><TD class="textualCELL">Use or create an incremental transfer list file<P>This is a handy option for tweaking lighting, especially on slow or lower memory machines.  BuildVisLeafs, MakeScales, and SwapTransfers can be skipped entirely on subsequent runs of hlrad.  Note that geometry must not change, but lighting can.
Using the incremental file requires a simple but important procedure:
<UL>
<LI>First hlrad is run normally with -incremental.  In addition to the map being lit normally, it will generate an incremental file, which is essentially the transfer lists dumped to disk.</LI>
<LI>Lights can be changed in any way (moved, brightness changed, color changed, etc)</LI>
<LI>Update the entities in the bsp with an hlcsg -onlyents compile.
<LI>Re-run rad normally again with the -incremental switch.  The exact same options for -extra, -chop, -texchop, -notexscale must be used on all the runs of hlrad.  All the other values may be tweaked.
</UL>
</TD></TR>

        <TR><TD class="topicalCELL" width="120"><B>-dump</B></TD><TD class="textualCELL">Dumps light patches to a file for hlrad debugging info<P>This is a developer option for zhlt, to dump out the patch data generated by the chopping/subdividing and make sure it looks alright.</TD></TR>
        </TABLE>
<TR><TD>
<TR><TD class="headingCELL"><BR>Entity Changes</TD></TR>
<TR><TD>
        <TABLE width="100%">
        <TR><TD class="topicalCELL" width="120"><B>_fade #</B></TD><TD class="textualCELL">Set fade (larger values = shorter lights).  Applies to any light, light_environment, or light_spot entities.<P>This value adds in an artificial factor into the normal (1 / dist * dist) inverse square falloff calculations, by multiplying the denominator of the scale by the fade value.  Point lights can set their own individual fade and falloff values, which override any global setting on the command line.  These calculations only affect the direct lighting layer, as the radiosity pass always uses plain inverse square falloff.  The default value is 1.0, and as you approach 0.0 the lights will travel much further, and as you go higher than 1.0, they will travel less.</TD></TR>
        <TR><TD class="topicalCELL" width="120"><B>_falloff #</B></TD><TD class="textualCELL">Set falloff mode (1 = inv linear, 2 = inv square).  Applies to any light, light_environment, light_spot entities.<P>This option can change the normal inverse square falloff of lighting in the direct lighting layer with inverse falloff.</TD></TR>
        <TR><TD class="topicalCELL" width="120"><B>zhlt_lightflags</B></TD><TD class="textualCELL">Set optional lightflags.  Can be applied to any brush based entity.<P><UL><LI>0 is default</LI><LI>1 is 'EmbeddedFix'</LI><LI>2 is the Opaque flag(blocks light)</LI><LI>3 is Opaque+EmbeddedFix</LI><LI>4 is 'ConcaveFix' (must be used with opaque, this setting is useless by itself)</LI><LI>6 is Opaque+ConcaveFix</LI></UL><P>For opaque brushes, it will be frequently necessary to place point lights inside the brush so that faces obscured by the brushes are properly lit (for example the trim adjacent to a func_door).  Setting the opaque bit is useful for most func_walls, some func_illusionary's, the occasional func_door, and possibly others for some effect.<P>The 'EmbeddedFix' is for telling hlrad to not used the complex light bleed fix on the entity, as sometimes when creating a brush entity that sticks through a wall, it will be lit incorrectly from the other side of the wall due to the bleed correction.</P><P>The 'ConcaveFix' is needed for curved func_walls, notably arch shapes.  When they are set to opaque, the inner curve (the concave porition) will frequently have black fringes at the joins where brushes touch up.  Setting the ConcaveFix flag fixes the black seams in these cases, but then the entity cannot have the EmbeddedFix set.</P></TD></TR>
        <TR><TD class="topicalCELL" width="120"><B>light_origin</B></TD><TD class="textualCELL">Set optional light placement.  Can be applied to any brush based entity.<P><UL><LI>light_origin can be used to place a brush based entity to a new location for the purposes of lighting.  Typical use requires placing an info_target at the relevant location, and then setting the light_origin to point the info_target's name.  If the entity is opaque, it will also cast shadows from that location in addition to being lit as if it were there.</TD></TR>
        </TABLE>
<TR><TD>
</TABLE>
   
<BR>
<H6>I can be reached via email at <A HREF="mailto:zoner@gearboxsoftware.com">zoner@gearboxsoftware.com</A></H6>

</BODY>
</HTML>